const fs = require('fs');
const path = require('path');

// Configuration
const BROADCAST_DIR = path.join(__dirname, '../contracts/broadcast/Deploy.s.sol/31337');
const FRONTEND_CONFIG_PATH = path.join(__dirname, '../frontend/src/config/contracts.ts');
const FRONTEND_ABI_DIR = path.join(__dirname, '../frontend/src/abis');

// Contract names to sync
const CONTRACTS = [
    'LendingPool',
    'AutonomyVault',
    'IPManager',
    'AutoRepayEngine',
    'InterestRateModel',
    'PriceOracle',
    'USDC',
    'USDT',
    'WETH',
    'WBTC',
    'DAI',
    'LINK',
    'UNI',
    'AAVE',
    'MockRoyaltyToken',
    'MockIPAssetRegistry',
    'MockRoyaltyVault',
    'MockRoyaltyModule',
    'MockUniswapRouter'
];

// Mapping for contracts defined in files with different names
const ARTIFACT_SOURCE_MAPPING = {
    'MockIPAssetRegistry': 'StoryProtocolMock.sol',
    'MockRoyaltyVault': 'StoryProtocolMock.sol',
    'MockRoyaltyModule': 'StoryProtocolMock.sol'
};

async function main() {
    console.log('üîÑ Syncing frontend with latest deployment...');

    // 1. Find latest run file
    if (!fs.existsSync(BROADCAST_DIR)) {
        console.error('‚ùå Broadcast directory not found. Did you run the deployment script?');
        process.exit(1);
    }

    const runFiles = fs.readdirSync(BROADCAST_DIR).filter(f => f.endsWith('.json') && f !== 'latest.json');
    if (runFiles.length === 0) {
        console.error('‚ùå No deployment runs found.');
        process.exit(1);
    }

    // Sort by modification time to get the latest
    const latestRunFile = runFiles.map(f => ({
        name: f,
        time: fs.statSync(path.join(BROADCAST_DIR, f)).mtime.getTime()
    })).sort((a, b) => b.time - a.time)[0].name;

    const runPath = path.join(BROADCAST_DIR, latestRunFile);
    console.log(`üìÑ Reading deployment from: ${latestRunFile}`);

    const runData = JSON.parse(fs.readFileSync(runPath, 'utf8'));
    const transactions = runData.transactions;
    const addresses = {};

    // 2. Extract addresses
    console.log('üîç Extracting addresses...');
    
    // Helper to find address by contract name
    // Note: Foundry broadcast JSONs can be tricky. We look for contract names in the transaction data.
    // Since we named our variables in the script (e.g. "usdc = new USDC()"), we can try to map them.
    // However, the broadcast file mainly contains transaction receipts.
    // A more robust way is to look at the "contractName" field if available, or infer from the order/creation code.
    // BUT, for simplicity and robustness in this specific setup, we can rely on the fact that we know the order 
    // OR we can use the `run-latest.json` which might have better structure, 
    // OR we can parse the `contractAddress` from the receipts if we can match the contract name.
    
    // Actually, `run-latest.json` is usually a symlink or copy of the latest run.
    // Let's iterate through transactions and try to match contract names.
    
    for (const tx of transactions) {
        if (tx.transactionType === 'CREATE') {
            const contractName = tx.contractName;
            if (contractName && CONTRACTS.includes(contractName)) {
                addresses[contractName] = tx.contractAddress;
                console.log(`   ‚úÖ Found ${contractName}: ${tx.contractAddress}`);
            }
        }
    }

    // 3. Update Frontend Config
    console.log('üìù Updating frontend config...');
    
    // Mapping from deployed contract name to frontend config key
    const KEY_MAPPING = {
        'LendingPool': 'LENDING_POOL',
        'AutonomyVault': 'AUTONOMY_VAULT',
        'IPManager': 'IP_MANAGER',
        'AutoRepayEngine': 'AUTO_REPAY_ENGINE',
        'InterestRateModel': 'INTEREST_RATE_MODEL',
        'PriceOracle': 'PRICE_ORACLE',
        // 'USDC': 'COLLATERAL_TOKEN', // Removed mapping, will use USDC
        'USDT': 'USDT',
        'WETH': 'WETH',
        'WBTC': 'WBTC',
        'DAI': 'DAI',
        'LINK': 'LINK',
        'UNI': 'UNI',
        'AAVE': 'AAVE'
    };

    let configContent = `// Auto-generated by scripts/sync-frontend.js
// Do not edit manually

`;

    // Add imports
    for (const contract of CONTRACTS) {
        configContent += `import ${contract}ABI from '../abis/${contract}.json';\n`;
    }

    configContent += `
export const CONTRACTS = {
`;

    for (const contract of CONTRACTS) {
        const addr = addresses[contract];
        // Use mapping if exists, otherwise use contract name as is (CamelCase)
        const key = KEY_MAPPING[contract] || contract;
        
        if (addr) {
            configContent += `    ${key}: {
        address: "${addr}",
        abi: ${contract}ABI,
    },\n`;
        } else {
            console.warn(`   ‚ö†Ô∏è  Warning: No address found for ${contract}`);
            configContent += `    ${key}: {
        address: "",
        abi: ${contract}ABI,
    },\n`;
        }
    }

    configContent += `} as const;

export const CHAIN_ID = 31337;
`;

    fs.writeFileSync(FRONTEND_CONFIG_PATH, configContent);
    console.log(`   ‚úÖ Wrote to ${FRONTEND_CONFIG_PATH}`);

    // 4. Copy ABIs
    console.log('üì¶ Copying ABIs...');
    if (!fs.existsSync(FRONTEND_ABI_DIR)) {
        fs.mkdirSync(FRONTEND_ABI_DIR, { recursive: true });
    }

    for (const contract of CONTRACTS) {
        // Foundry artifacts are in contracts/out/<ContractName>.sol/<ContractName>.json
        // Check if there's a custom source mapping
        const sourceFile = ARTIFACT_SOURCE_MAPPING[contract] || `${contract}.sol`;
        const artifactPath = path.join(__dirname, `../contracts/out/${sourceFile}/${contract}.json`);
        
        if (fs.existsSync(artifactPath)) {
            const artifact = JSON.parse(fs.readFileSync(artifactPath, 'utf8'));
            const abiContent = JSON.stringify(artifact.abi, null, 2);
            const abiDest = path.join(FRONTEND_ABI_DIR, `${contract}.json`);
            fs.writeFileSync(abiDest, abiContent);
            console.log(`   ‚úÖ Copied ABI for ${contract}`);
        } else {
            console.warn(`   ‚ö†Ô∏è  Warning: Artifact not found for ${contract}`);
        }
    }

    console.log('üéâ Sync complete!');
}

main().catch(console.error);
